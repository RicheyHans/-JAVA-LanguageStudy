## Chapter 06. Class (클래스)

## 6.1 객체 지향 프로그래밍
특정 제품 개발 시, 부품에 해당하는 개체를 먼저 만들고 이것을 조립해 완성된 프로그램을 만드는 기법

### 6.1.1 객체
* 객체 : 물리/추상적인 존재 중 자신의 속성을 갖고 다른 것과 구별 가능한 것.
  * 속성(Field)과 동작(Method)를 갖는다.
  * 객체 모델링 : 현실 세계의 객체를 SW 객체로 설계하는 것

### 6.1.2 객체의 상호작용
### 6.1.3 객체 간 관계
* 집합 관계, 사용 관계, 상속 관계
### 6.1.4 객체 지향 프로그래밍 특징
* 캡슐화, 상속, 다형성

<br>

## 6.2 객체와 클래스
* 현실 객체 > 설계도/클래스(필드, 메서드) 작성 > 인스턴스 화 > 실제 사용할 인스턴스(객체)

<br>

## 6.3 클래스 선언
* 한 파일에 두 개 이상의 클래스를 생성하면 바이트코드 파일(~.class) 파일은 선언한 개수 만큼 생성
* 파일 이름과 동일한 이름의 클래스만 public 선언이 가능함.

<br>

## 6.4 객체 생성과 클래스 변수
* new + 생성자 : 클래스로부터 객체를 인스턴스 화 시킨다.
  * heap 영역에 클래스의 객체를 생성 한 후, 클래스 변수(참조 타입)에 객체의 메모리 주소 리턴
    ```
    Student s1 = new Student();
    ```
    > Stack 영역에 생성된 변수 s1에는 heap영역에 생성된 Student객체의 메모리 주소 저장

  * new로 생성된 객체는 각각 다른 별개의 메모리 주소를 갖는 객체이다.

<br>

## 6.5 클래스의 구성
* 필드, 생성자, 메소드

### 6.5.1 필드
* 객체 고유 데이터, 상태 정보 저장 / '변수'와 달리 객체가 소멸되지 않는 한 존재

### 6.5.2 생성자
* new 연산자로 호출되는 { } 블록. 객체 생성 시 초기화 또는 메서드를 호출한다.

### 6.5.3 메소드
* 객체의 동작에 해당하는 중괄호 블록

<br>

## 6.6 필드
### 6.6.1 필드 선언
* 클래스 { } 블록 내 어디서든 선언 가능
* 단, 생성자 / 메서드 내 선언된 것은 **로컬 변수**
* 초기화 값이 지정되지 않은 필드는 **자동으로 기본 초기값 설정이 된다.**
  * 기본 타입은 0 위주, 참조 타입은 null
  * 필드를 선언만 한 후 System.out.println 출력 시 0 또는 null 등의 값이 출력된다.

### 6.6.2 필드 사용
* 클래스 내부에서 사용할 경우 바로 사용 가능
* 클래스 외부에서 사용할 경우 **객체를 생성한 후** 사용해야 한다.
  * 필드는 객체 소속 데이터이므로 객체가 없으면 존재할 수 없다.

<br>

## 6.7 생성자
* 생성자는 new 연산자와 함께 사용되어 객체 생성 시 호출되어 객체의 초기화를 담당한다.
  * 생성자를 실행 시키지 않으면 클래스를 인스턴스 화 시킬 수 없음
  * 인스턴스 화 성공할 경우 heap 영역에 객체가 생성되고 객체의 주소가 변수에 리턴

### 6.7.1 기본 생성자
* 모든 클래스는 반드시 생성가를 가지며, 생략할 경우 기본 생성자가 자동으로 바이트 코드에 추가
* 단, 명시적으로 하나 이상의 생성자가 있으면 기본 생성자는 추가되지 않는다.

### 6.7.2 생성자 선언
* 명시적 선언자가 있을 경우, 기본 생성자는 사용할 수 없다.

### 6.7.3 필드 초기화
* 필드는 객체 생성 시 자동으로 기본 초기값이 설정 된다.
* 또는 선언 시 초기화, 생성자 초기화 가능
* 필드와 생성자 파라미터 명이 동일할 경우, 우선순위는 파라미터가 더 높으므로 필드에는 this를 사용한다.
  ```
  public Korean(String name, String ssn){
    this.name = name;
    this.ssn = ssn;
  }
  ```

### 6.7.4 생성자 오버로딩
* 매개 변수를 달리하는 생성자를 다수 선언하는 것
  ```
  public class Phone{
    public Phone(){}
    public Phone(String name){}
    public Phone(String name, int modelNum){}
  }
  ```

  ```
  Phone phone = new Phone();
  Phone phone = new Phone("iPhone");
  Phone phone = new Phone("iPhoneX", 00128);
  ```
### 6.7.5 다른 생성자 호출( this() )(pending)

<br>

## 6.8 메소드

### 6.8.1 메서드 선언

### 6.8.2 return
* 자동 변환이 가능한 타입일 경우 return 타입이 다를 수 있음

### 6.8.3 메서드 호출
* 클래스 외부에서 메서드를 호출할 경우 객체 생성 후 호출해야 한다. (메서드는 객체가 존재해야 존재 가능)

### 6.8.4 메서드 Overloading
* 클래스 내에 같은 이름의 메서드를 다수 선언하는 것
* 메서드 이름은 동일하며 파라미터의 타입, 개수, 순서가 달라야 한다.
  * 파라미터 자동 변환 발생 가능
  * 리턴 타입은 무관
* 대표적인 예는 System.out.println( )
  * 파라미터 타입에 따라 출력 동작이 발생한다.

<br>

## 6.9 인스턴스 멤버와 this
* 인스턴스 멤버는 객체(인스턴스) 생성 후 사용할 수 있는 필드와 메서드를 의미
  * 인스턴스 필드 : heap 영역에 개별로 생성된 객체마다 존재한다.
  * **인스턴스 메서드 : JVM 메서드 메모리 영역에 저장되어 공유**

* this는 객체 자신을 의미한다.

<br>

## 6.10 static(정적 멤버)
정적 멤버는 **클래스** 에 고정된 멤버
  * 객체 생성 없이 사용할 수 있는 필드 / 메서드

### 6.10.1 정적 멤버 선언
* 정적 필드 / 메서드는 클래스 로더가 클래스 바이트 코드 로딩 후 메소드 메모리 영역에 적재한다.
  * **클래스 로딩이 완료되면 객체 생성 없이 바로 사용이 가능하다**

### 6.10.2 정적 멤버 사용
* 정적 멤버는 개체 생성 없이, 클래스의 이름과 함께 바로 사용이 가능하다.
  ```
  public class Calculaltor{
    ststic double pi = 3.1459;
  }
  ...
  double result = Calculator.pi + 128;
  ```
### 6.10.3 정적 필드 초기화 블록
* 정적 필드는 통상적으로 선언과 동시에 초기화
  ```
  static double pi = 3.1459;
  ```
  > static 필드는 인스턴스 생성 없이 사용 가능해야 하므로, **생성자를 통한 초기화가 불가능**

* 별도 연산 작업이 포함된 static 필드 초기화 작업은 static 블록에서 진행
  * 클래스 로딩 시 자동 실행
    ```
    static String info;

    static{
      info = "version" + "number";
    }
    ```

### 6.10.4 정적 메서드 블록 선선 시 주의
* 정적 메서드, 블록 선언 시 주의 사항
  * static 블록은 **객체가 없어도 실행** 된다는 특징이 있으므로, 객체 생성 후 사용이 가능한 **인스턴스 필드, 인스턴스 메서드** 를 사용할 수 없다.
  * static 블록 내에서 인스턴스 멤버를 사용하기 위해서는 **객체를 생성한 후** 사용해야 한다.

### 6.10.5 싱글톤(Singleton)
* 프로그램 상에 **단 하나의 객체** 만을 생성해서 관리할 경우
  * 주 기능 : 클래스 외부에서 **new 연산자로 생성자를 호출 할 수 없어야 한다.**<br>
             (객체는 new 연산자만큼 생성된다)

1. 생성자에 private을 붙여 외부 클래스 호출을 막는다.
2. 내부에서 클래스 타입의 private 정적 변수를 생성해 new 연산자를 호출한다.
3. 클래스 내부에 정적 메서드인 getInstance(){ } 를 생성해 2.에서 생성한 정적 변수를 return한다.

```
public class SingletonExample{
  // 생성자
  private SingletonExample(){ }

  // static 필드
  private static SingletonExample singleton = new SingletonExample();

  // static 메서드
  static SingletonExample getInstance(){
    return singleton;
  }
}

public class Main{
  public static void main(String[] args){
    Singleton obj1 = Singleton.getInstance;
  }
}
```
