## Chapter 06. Class (클래스)

## 6.1 객체 지향 프로그래밍
특정 제품 개발 시, 부품에 해당하는 개체를 먼저 만들고 이것을 조립해 완성된 프로그램을 만드는 기법

### 6.1.1 객체
* 객체 : 물리/추상적인 존재 중 자신의 속성을 갖고 다른 것과 구별 가능한 것.
  * 속성(Field)과 동작(Method)를 갖는다.
  * 객체 모델링 : 현실 세계의 객체를 SW 객체로 설계하는 것

### 6.1.2 객체의 상호작용
### 6.1.3 객체 간 관계
* 집합 관계, 사용 관계, 상속 관계
### 6.1.4 객체 지향 프로그래밍 특징
* 캡슐화, 상속, 다형성

<br>

## 6.2 객체와 클래스
* 현실 객체 > 설계도/클래스(필드, 메서드) 작성 > 인스턴스 화 > 실제 사용할 인스턴스(객체)

<br>

## 6.3 클래스 선언
* 한 파일에 두 개 이상의 클래스를 생성하면 바이트코드 파일(~.class) 파일은 선언한 개수 만큼 생성
* 파일 이름과 동일한 이름의 클래스만 public 선언이 가능함.

<br>

## 6.4 객체 생성과 클래스 변수
* new + 생성자 : 클래스로부터 객체를 인스턴스 화 시킨다.
  * heap 영역에 클래스의 객체를 생성 한 후, 클래스 변수(참조 타입)에 객체의 메모리 주소 리턴
    ```
    Student s1 = new Student();
    ```
    > Stack 영역에 생성된 변수 s1에는 heap영역에 생성된 Student객체의 메모리 주소 저장

  * new로 생성된 객체는 각각 다른 별개의 메모리 주소를 갖는 객체이다.

<br>

## 6.5 클래스의 구성
* 필드, 생성자, 메소드

### 6.5.1 필드
* 객체 고유 데이터, 상태 정보 저장 / '변수'와 달리 객체가 소멸되지 않는 한 존재

### 6.5.2 생성자
* new 연산자로 호출되는 { } 블록. 객체 생성 시 초기화 또는 메서드를 호출한다.

### 6.5.3 메소드
* 객체의 동작에 해당하는 중괄호 블록

<br>

## 6.6 필드
### 6.6.1 필드 선언
* 클래스 { } 블록 내 어디서든 선언 가능
* 단, 생성자 / 메서드 내 선언된 것은 **로컬 변수**
* 초기화 값이 지정되지 않은 필드는 **자동으로 기본 초기값 설정이 된다.**
  * 기본 타입은 0 위주, 참조 타입은 null
  * 필드를 선언만 한 후 System.out.println 출력 시 0 또는 null 등의 값이 출력된다.

### 6.6.2 필드 사용
* 클래스 내부에서 사용할 경우 바로 사용 가능
* 클래스 외부에서 사용할 경우 **객체를 생성한 후** 사용해야 한다.
  * 필드는 객체 소속 데이터이므로 객체가 없으면 존재할 수 없다.

<br>

## 6.7 생성자
* 생성자는 new 연산자와 함께 사용되어 객체 생성 시 호출되어 객체의 초기화를 담당한다.
  * 생성자를 실행 시키지 않으면 클래스를 인스턴스 화 시킬 수 없음
  * 인스턴스 화 성공할 경우 heap 영역에 객체가 생성되고 객체의 주소가 변수에 리턴

### 6.7.1 기본 생성자
* 모든 클래스는 반드시 생성가를 가지며, 생략할 경우 기본 생성자가 자동으로 바이트 코드에 추가
* 단, 명시적으로 하나 이상의 생성자가 있으면 기본 생성자는 추가되지 않는다.

### 6.7.2 생성자 선언
* 명시적 선언자가 있을 경우, 기본 생성자는 사용할 수 없다.

### 6.7.3 
